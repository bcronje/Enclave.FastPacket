// <auto-generated />
using Microsoft.CodeAnalysis;
using System;
using System.Net.Sockets;
using System.Reflection.Metadata;

#nullable enable

namespace Enclave.FastPacket.Generator
{
    /// <summary>
    /// Attribute used to customise the generation of a single field in a packet.
    /// </summary>
    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Struct)]
    internal sealed class PacketFieldAttribute : Attribute
    {
        /// <summary>
        /// Create a new <see cref="PacketFieldAttribute"/>. Customise the
        /// field using named arguments.
        /// </summary>
        public PacketFieldAttribute()
        {
        }

        /// <summary>
        /// Specify a fixed number of bytes that this field consumes in the packet.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Typically you would set this on a <see cref="ReadOnlySpan{byte}"/> or <see cref="Span{byte}"/> field,
        /// to indicate the exact length of the buffer slice returned.
        /// </para>
        /// <para>
        /// The start position of all fields following this one will be adjusted to accomodate this size.
        /// </para>
        /// <para>
        /// If you set this on a primitive/numeric field with a return type smaller (in bytes) than the provided size,
        /// the value of the field will be read from the *start* of the position, not the end, with the remaining bytes of the field ignored.
        /// </para>
        /// <para>
        /// For example, if you provide a <see cref="Size"/> of 6 bytes, and a field type of <c>uint</c> (4 bytes in size), then the first 4 bytes
        /// in the buffer will be used to populate the return value, with the last 2 bytes ignored.
        /// </para>
        /// </remarks>
        public int Size { get; set; }

        /// <summary>
        /// Specify the name of a function that can return the dynamic size of a field within the packet at runtime.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Size functions are powerful ways to express the size of a field within a packet, since they execute code at runtime
        /// to compute the 
        /// </para>
        /// <para>
        /// Size functions must be <c>public static</c> methods within the definition type, with either of the following signatures:
        /// <code>
        /// public static int FunctionName(ReadOnlySpan&lt;byte&gt; span);
        /// public static int FunctionName(ReadOnlySpan&lt;byte&gt; span, int position);
        /// </code>
        /// In both versions, the `packet` parameter contains the *entire* packet buffer for inspection.
        /// In the second version, the position parameter tells you the known location of the field this attribute is attached to, in
        /// case the length is stored somewhere in that field.
        /// </para>
        /// <para>
        /// Note that you can reference the generated packet implementations in your size function to read fields from the packet that occur
        /// *before* this one.
        /// </para>
        /// <para>
        /// The start position of all fields following this one will be adjusted to accomodate the size returned by the function.
        /// </para>
        /// </remarks>
        public string? SizeFunction { get; set; }

        /// <summary>
        /// Specify the name of another field in the same packet that can provide the size of this field.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The field in question should be a numeric field prior to this field in the byte order.
        /// </para>      
        /// <para>
        /// The start position of all fields following this one will be adjusted to accomodate the size returned by that field.
        /// </para>
        /// </remarks>
        public string? SizeField { get; set; }

        /// <summary>
        /// Specify an explicit position for this field, in bytes offset from the beginning of the packet.
        /// </summary>
        /// <remarks>
        /// <para>
        /// In most cases you should avoid using this property; position can usually be automatically determined from the other fields in the packet.
        /// </para>
        /// <para>
        /// The start position of all fields following this one will be adjusted to accomodate this size.
        /// </para>
        /// </remarks>
        public int Position { get; set; }

        /// <summary>
        /// Specify the name of a function that can return the dynamic position of a field in bytes offset from the beginning of the packet.
        /// </summary>
        /// <remarks>
        /// <para>
        /// In most cases you should avoid using this property; position can usually be automatically determined from the other fields in the packet.
        /// </para>
        /// <para>
        /// Position functions must be <c>public static</c> methods within the definition type, with the following signature:
        /// <code>
        /// public static int FunctionName(ReadOnlySpan&lt;byte&gt; packetData, int defaultPosition);
        /// </code>
        /// </para>
        /// <para>
        /// The start position of all fields following this one will be adjusted to accomodate the size returned by the function.
        /// </para>
        /// </remarks>
        public string? PositionFunction { get; set; }

        /// <summary>
        /// Specify an explicit numeric backing type for an enumeration field, if it's not possible to modify the enum declaration.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If you specify that an enum derives from byte, e.g.
        /// <code>
        /// public enum MyEnum : byte
        /// {
        ///   // enum members...
        /// }
        /// </code>
        /// Then the generator will automatically use that as the backing type.
        /// </para>
        /// <para>
        /// For enums that you cannot control, or are defined in the framework, you can set that underlying numeric type with this property.
        /// </para>
        /// </remarks>
        public Type? EnumBackingType { get; set; }

        /// <summary>
        /// Specify a bitmask for this field, indicating which bits of the underlying bytes are actually used to populate the field value.
        /// </summary>
        /// <remarks>
        /// Instead of directly specifying the bitmask, you may find it easier to use the <see cref="PacketFieldBitsAttribute"/>
        /// to specify a bitmask as start and end bits, as often found in network packet RFCs.
        /// </remarks>
        public ulong Bitmask { get; set; }
    }

    /// <summary>
    /// Allows a field to occupy only a subset of bits within the read value.
    /// Bit numbers are specified using MSB 0 bit-numbering, to match most network packet RFCs.
    /// </summary>
    /// <remarks>
    /// <code>
    /// Whenever an octet represents a numeric quantity the left most bit in
    /// the diagram is the high order or most significant bit.That is, the
    /// bit labeled 0 is the most significant bit.For example, the following
    /// diagram represents the value 170 (decimal).
    ///
    ///
    ///                0 1 2 3 4 5 6 7
    ///               +-+-+-+-+-+-+-+-+
    ///               |1 0 1 0 1 0 1 0|
    ///               +-+-+-+-+-+-+-+-+
    ///
    ///              Significance of Bits
    ///
    /// Similarly, whenever a multi-octet field represents a numeric quantity
    /// the left most bit of the whole field is the most significant bit.
    /// </code>
    /// </remarks>
    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Struct)]
    internal sealed class PacketFieldBitsAttribute : Attribute
    {
        /// <summary>
        /// Define a packet field that consumes only a specified set of bits within the read value.
        /// Bit numbers are specified using MSB 0 bit-numbering, to match most network packet RFCs.
        /// </summary>
        /// <param name="firstBit">The first bit to include in the value (e.g. 0)</param>
        /// <param name="lastBit">The last bit to include in the value (e.g. 7)</param>
        public PacketFieldBitsAttribute(uint firstBit, uint lastBit)
        {
            FirstBit = firstBit;
            LastBit = lastBit;
        }

        /// <summary>
        /// Define a packet field that consumes a single bit within the read value.
        /// Bit numbers are specified using MSB 0 bit-numbering, to match most network packet RFCs.
        /// </summary>
        /// <param name="bit">The bit to include in the value (e.g. 0)</param>
        public PacketFieldBitsAttribute(uint bit)
        {
            FirstBit = bit;
            LastBit = bit;
        }

        public uint FirstBit { get; }

        public uint LastBit { get; }
    }
}
